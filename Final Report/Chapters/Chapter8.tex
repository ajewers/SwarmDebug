% Chapter 8

\chapter[Design]{Design} % Main chapter title

\label{Chapter8} % For referencing the chapter elsewhere, use \ref{Chapter8} 

%----------------------------------------------------------------------------------------

This section describes the design of the system, and gives details of the reasoning behind some of the design decisions. This design work was done largely prior to implementation, with some elements of the design being re-factored during the implementation phase in adherence to the agile development methodology being followed. The design process was broken down into a number of key areas. Firstly the design of the software architecture, including the breakdown of the different components and the path of data through the system. This served as a road map during the implementation stage. The second key area was the user interface design. This involved determining how the main application should appear to the user, how best to provide the user with access to the various features, and then creating a template of the window and component layout required to achieve this. Graphical representations were also designed for each of the data types to be displayed in the visualiser.

%----------------------------------------------------------------------------------------

\section{Software Architecture Design}
The guiding principles of the software architecture design were `Object Oriented Programming' (OOP) practices, and the `model-view-controller' (MVC) software architecture pattern. OOP \cite{OOP} is an extremely widespread concept in modern software development theory. It states that code should be organised into units based on individual functionalities, commonly referred to as classes. Each class collects together the data that describes an object and the routines to perform actions with and on that data. A class then acts as a template, and a new instance of the class can be instantiated each time an object of that type is needed. OOP aims to make code easier to understanding and maintain, reduce code duplication, and increase re-usability and modularity. Designing software in an OOP fashion is standard practice for most modern programming tasks, and modern languages are often designed around OOP concepts. C++ was selected as the development language for this application as it offers much of the low level control and efficiency of the C language, whilst also supporting OOP practices natively. The majority of the existing software infrastructure in the YRL had also been implemented in C++, hence following suit would help with maintainability and integration in the future. Considering the project's requirements for interfacing with low level hardware such as the tracking camera (via a driver) and the robots (via network sockets), and for performing image processing, the speed and low level capabilities of C++ also seemed beneficial. Higher level languages such as Java were considered, as they offered a number of different benefits such as better portability and automatic resource management, but were ultimately deemed less suitable.

The MVC software architecture design pattern is another widespread concept in software development theory. It primarily relates to the programming of applications with user interfaces. The three words that give the pattern its name - model, view and controller - define the three 'layers' into which code components are organised. The model refers to the application's data, and includes all of the information that defines an application's current state. The view refers to the code used to produce the user interface from the data in the model layer. It acts as the method by which the user 'views' the data, thus getting its name. Finally the controller layer acts as the intermediary between the two, retrieving data from the model and processing it if necessary before passing it to the view for display. The controller also responds to input and changes the data in the model accordingly. This includes data input via the user through the view, as well as data from other sources. In the case of this application these other sources include the peripherals, such as the tracking camera, and the robots via the WiFi network. Adhering to an MVC pattern helps to keep code structured and organised, making it easier to understand, maintain and extend. It ensures that state data is not maintained or duplicated within the UI code, and that only one, true copy of the application data exists, stored in the model layer.

With these two principles in mind, the software design process could begin. First the application was broken down into individual components based on the functional specification. The following key areas were identified:

\begin{itemize}
\item Code to handle communicating with the camera and retrieving the image data.
\item Code to perform the robot tracking.
\item Code to handle the networking, including receiving data from the robots.
\item Code defining a model to store the robot data in.
\item Code to enter new data into the model.
\item Code to augment the video feed based on the stored data.
\item Code to display the video and augmentations feed to the user.
\item Code to respond to user input via the user interface
\item Code to store user settings
\end{itemize}

Once separated into functional components, the required code blocks could be organised into a structure, and the data path of the application examined. Figure \ref{fig:SoftwareArchitecture} shows this structural arrangement, with boxes for each of the functional objects and arrows indicating data flow. The three layers of the MVC design pattern are shown by the vertical partitioning. The horizontal partitioning is used to show another key design consideration - threading. In order to maximise performance and ensure responsiveness, functionality which has the potential to `block' execution whilst waiting for a result or response should be run in a separate thread. This application was therefore designed with three threads in mind. The main thread handles the core of the application, including all data model access and GUI operations. The network thread handles communicating with the robots via WiFi. It was anticipated that this networking would involve low level socket code, which meant the potential for blocking socket-read operations, therefore requiring a separate thread. The camera thread handles reading the machine vision camera and performing the tag tracking using the ARuCo library. It was anticipated that the camera read operation could block until the next frame was available in the camera driver's buffer. Tracking the robots in the image using the ARuCo library also had the potential to be CPU intensive, so keeping this off the main thread was considered a potential performance benefit.

\begin{figure}
	\centering
	\includegraphics[scale=0.7]{Figures/SoftwareArchitecture.png}
	\decoRule
	\caption[Software Architecture Diagram]{A diagram of the software architecture design and data flow.}
	\label{fig:SoftwareArchitecture}
\end{figure}

As can be seen in figure \ref{fig:SoftwareArchitecture}, the software architecture is structured around a central application controller. The data from all other components of the application flows through this central component, which routes it to where it needs to go. It is also responsible for updating the visualiser and GUI with new data when necessary, and acting on the user input signals received through the UI. The other key controller layer components - the network controller and the camera controller - exhibit data flow in only one direction. The design of these components was therefore relatively simple, as they needed only to perform the following loop of tasks:

\begin{enumerate}
 \item Receive data from external source.
 \item Process data as necessary, extracting required information.
 \item Notify the application controller of the newly available data.
 \item Wait for new data to become available.
\end{enumerate}

The remaining components are more complex, and required greater software design considerations. The design of the data model is discussed in section \ref{DataModelDesign}. The design of the visualiser code is discussed in section \ref{VisualiserDesign}.

\subsection{Data Model} \label{DataModelDesign}
The purpose of the data model component is to store all of the data required to describe the applications current state. This includes all data related to each of the robots being tracked by the system. In order to achieve this in an object oriented manner the data model itself was designed to be comprised of a number of smaller components in a hierarchical structure. The main data model object maintains a collection of smaller objects, each containing the data related to a single robot. These in turn maintain a collection of different data objects relating to the robot's state and sensor data. Figure \ref{fig:DataModel} illustrates this hierarchical data model design using the IR sensor data of a single robot as an example.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{Figures/DataModel.png}
	\decoRule
	\caption[Data Model Diagram]{A diagram of the data model design.}
	\label{fig:DataModel}
\end{figure}

This follows object oriented programming practices by defining a single class to describe a robot, from which a new robot data object can be instantiated each time the system begins tracking a new robot. When data is received regarding a robot the system is already aware of, it can simply update the correct existing robot data object with the new data.

\subsection{Visualiser} \label{VisualiserDesign}
The purpose of the visualiser component is to generate and display the augmented video feed to the user. The component therefore receives the latest camera image and the most up to date robot data, generating the graphical overlays based on a combination of the robot data and the current settings for each visualisation. It then displays the latest image, with the graphical overlays applied, to the user by rendering it as a single image within the appropriate GUI element. This rendering process occurs each time a new video frame is read from the camera, hence both the video and the overlays should update regularly and respond rapidly to changes in the robot data.

In order to further modularise the visualiser code, it was broken down into a number of smaller components. For each type of data visualisation a separate component was defined, which describes how the visualisation for that data type is generated, based on a single robot data object. The main visualiser component could then be designed to generate the graphical overlays iteratively, by stepping through the available set of robot data objects, and for each one step through the different visualisation components, generating the overlay for each combination. The overlays can then be combined and displayed as a single image. Figure \ref{fig:VisualiserProcess} describes this process diagrammatically.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{Figures/VisualiserProcess.png}
	\decoRule
	\caption[Visualiser Render Process Design]{A diagram describing the design of the visualiser rendering process.}
	\label{fig:VisualiserProcess}
\end{figure}

%----------------------------------------------------------------------------------------

\section{User Interface Design}
The second main area of consideration during the design phase was the Graphical User Interface (GUI). It was determined that a well designed, intuitive interface would be essential to satisfying the objective of providing the user with data in a 'human readable' form, in real time. Having real time data would be useless if the user cannot also parse the data displayed in approximately real time. The first decision made was to try and keep the interface familiar to a computer user, through the use of standard, widely understood user interface elements. There exists a well defined `language' in computer interface design, using constructs such as windows, tabs, buttons, text fields and other elements which have well understood functions. It was thought that basing the user interface design on this well established standard would minimize the time for a new user to become accustomed to the system. The next step was determining how many windows would be necessary for the intended functionality to be possible, and how best to lay these out and organise the other elements within each. Three main windows were determined to be necessary. The first would display the video feed and visual overlay, the key component of the application. A second window would be used to display a list of the robots known to the system, so that they could be selected without obscuring the visualiser. Finally a third window would be used to display more detailed information about the selected robot in a number of different tabs. Figure \ref{fig:UILayout} shows the basic layout decided on for these three windows.

\begin{figure}
	\centering
	\includegraphics[scale=1]{Figures/UILayout.png}
	\decoRule
	\caption[UI Layout]{The design of the basic user interface layout.}
	\label{fig:UILayout}
\end{figure}

The visualiser window, highlighted in blue, takes primary place in the layout. In order to maximise the readability of the augmented video feed it was determined that this window should occupy as much space as possible. A number of tabs would then be contained in this window to give access to various settings, including settings for the visualiser. The robot list window is highlighted in green on the right hand side. This window requires less width, as it's main function is simply to display the robot list. A number of tabs would also be added here, to allow access to functionality related to the robots such as settings for the network connection. Finally the data window is highlighted in yellow at the bottom of the layout. The tabs would be used to provide more detailed info on each type of data collected about the selected robot, as well as a tab for a general overview, and a console-style log of application events. It was noted that when displaying data in this window it should be formatted to maximise the use of the available space. This means using the full width of the window and limiting the height to avoid scrolling. The design also includes a toolbar at the top of the window, another standard feature of window-based software applications.

Figure \ref{fig:UIExample} shows how this layout might look when filled with some example content. The robot list identifies the two robots being tracked by the system. The visualiser component shows the video image, augmented with the graphical overlays generated from the data about the two robots.

\begin{figure}
	\centering
	\includegraphics[scale=1]{Figures/UIExample.png}
	\decoRule
	\caption[UI Example]{The basic UI design, filled with some example content.}
	\label{fig:UIExample}
\end{figure}

\subsection{The Qt Framework}
In order to make creating this interface feasible, a GUI framework needed to be selected. Many GUI frameworks exist, each with various benefits. For this application the Qt Application User Interface framework for desktop was selected. This framework provides a comprehensive library of classes and an application programming interface (API) for implementing desktop user interfaces, with support for all the standard features of window-based applications. The Qt framework was chosen for a number of reasons. The framework is fairly widely used, and therefore has a well-tested, refined, and mature API, with a good body of documentation available. Previous experience with Qt outside of this project had been positive, and meant a smaller learning curve would be necessary to get started developing with it. For non-commercial projects Qt is also available free of charge, making it a good fit for an academic project such as this.

%----------------------------------------------------------------------------------------